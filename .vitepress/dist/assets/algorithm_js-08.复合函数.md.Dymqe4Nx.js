import{_ as n,c as s,o as p,ag as e}from"./chunks/framework.DPDPlp3K.js";const u=JSON.parse('{"title":"复合函数","description":"","frontmatter":{},"headers":[],"relativePath":"algorithm/js-08.复合函数.md","filePath":"algorithm/js-08.复合函数.md"}'),t={name:"algorithm/js-08.复合函数.md"};function i(l,a,o,c,r,h){return p(),s("div",null,a[0]||(a[0]=[e(`<h1 id="复合函数" tabindex="-1">复合函数 <a class="header-anchor" href="#复合函数" aria-label="Permalink to &quot;复合函数&quot;">​</a></h1><h2 id="题目" tabindex="-1">题目 <a class="header-anchor" href="#题目" aria-label="Permalink to &quot;题目&quot;">​</a></h2><p>请你编写一个函数，它接收一个函数数组 [f1, f2, f3，…， fn] ，并返回一个新的函数 fn ，它是函数数组的 复合函数 。</p><p>[f(x)， g(x)， h(x)] 的 复合函数 为 fn(x) = f(g(h(x))) 。</p><p>一个空函数列表的 复合函数 是 恒等函数 f(x) = x 。</p><p>你可以假设数组中的每个函数接受一个整型参数作为输入，并返回一个整型作为输出。</p><p>示例 1：</p><p>输入：functions = [x =&gt; x + 1, x =&gt; x * x, x =&gt; 2 * x], x = 4</p><p>输出：65</p><p>解释：</p><p>从右向左计算......</p><p>Starting with x = 4.</p><p>2 * (4) = 8</p><p>(8) * (8) = 64</p><p>(64) + 1 = 65</p><p>示例 2：</p><p>输入：functions = [x =&gt; 10 * x, x =&gt; 10 * x, x =&gt; 10 * x], x = 1</p><p>输出：1000</p><p>解释：</p><p>从右向左计算......</p><p>10 * (1) = 10</p><p>10 * (10) = 100</p><p>10 * (100) = 1000</p><p>示例 3：</p><p>输入：functions = [], x = 42</p><p>输出：42</p><p>解释：</p><p>空函数列表的复合函数就是恒等函数</p><p>提示：</p><p>-1000 &lt;= x &lt;= 1000</p><p>0 &lt;= functions.length &lt;= 1000</p><p>所有函数都接受并返回一个整型</p><h2 id="答案" tabindex="-1">答案 <a class="header-anchor" href="#答案" aria-label="Permalink to &quot;答案&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>var compose = function(functions) {</span></span>
<span class="line"><span>	return function(x) {</span></span>
<span class="line"><span>        if(functions.length==0){</span></span>
<span class="line"><span>            return x;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        else{</span></span>
<span class="line"><span>            let res=x;</span></span>
<span class="line"><span>            for(let i=functions.length-1;i&gt;=0;i--){</span></span>
<span class="line"><span>                res=functions[i](res);</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>            return res;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>};</span></span></code></pre></div><h2 id="扩展" tabindex="-1">扩展 <a class="header-anchor" href="#扩展" aria-label="Permalink to &quot;扩展&quot;">​</a></h2><p>数组倒置</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>nums.reverse()</span></span></code></pre></div>`,37)]))}const x=n(t,[["render",i]]);export{u as __pageData,x as default};
