# 排序方式

## 问题

给定一个数组 arr 和一个函数 fn，返回一个排序后的数组 sortedArr。你可以假设 fn 只返回数字，并且这些数字决定了 sortedArr 的排序顺序。sortedArr 必须按照 fn 的输出值 升序 排序。

你可以假设对于给定的数组，fn 不会返回重复的数字。

示例 1：

输入：arr = [5, 4, 1, 2, 3], fn = (x) => x

输出：[1, 2, 3, 4, 5]

解释：fn 只是返回传入的数字，因此数组按升序排序。

示例 2：

输入：arr = [{"x": 1}, {"x": 0}, {"x": -1}], fn = (d) => d.x

输出：[{"x": -1}, {"x": 0}, {"x": 1}]

解释：fn 返回 "x" 键的值，因此数组根据该值排序。

示例 3：

输入：arr = [[3, 4], [5, 2], [10, 1]], fn = (x) => x[1]

输出：[[10, 1], [5, 2], [3, 4]]

解释：数组按照索引为 1 处的数字升序排序。

提示：

arr 是一个有效的 JSON 数组

fn 是一个函数，返回一个数字

1 <= arr.length <= 5 \* 105

## 答案
```
var sortBy = function(arr, fn) {
    arr.sort((a,b)=>fn(a)-fn(b));
    return arr;
};
```
## 扩展
Array.sort() 允许我们传递一个比较函数，以自定义排序机制。比较函数应该是一个接受两个参数并返回一个负数、零或正数的函数：

- 负数：如果比较函数返回一个小于零的值，它将把 a 排到 b 之前。简单来说，a 应该在 b 之前。
- 正数：如果比较函数返回一个大于零的值，它将把 a 排到 b 之后。也就是说，a 应该在 b 之后。
- 零：如果比较函数返回 0，它会保持 a 和 b 相对于彼此的顺序不变，但它们相对于其他元素的顺序将被排序。

```
arr.sort((a,b)=>a-b);//升序
```